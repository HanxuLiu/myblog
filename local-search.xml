<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TCP 协议简介</title>
    <link href="/2021/06/10/%E9%98%AE%E4%B8%80%E5%B3%B0_TCP%20%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/06/10/%E9%98%AE%E4%B8%80%E5%B3%B0_TCP%20%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-协议简介"><a href="#TCP-协议简介" class="headerlink" title="TCP 协议简介"></a>TCP 协议简介</h1><p>作者： <a href="http://www.ruanyifeng.com/">阮一峰</a></p><p>日期： <a href="http://www.ruanyifeng.com/blog/2017/06/">2017 年 6 月 8 日</a></p><p>TCP 是互联网核心协议之一，本文介绍它的基础知识。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060801.png"></p><h2 id="一、TCP-协议的作用"><a href="#一、TCP-协议的作用" class="headerlink" title="一、TCP 协议的作用"></a>一、TCP 协议的作用</h2><p>互联网由<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">一整套协议</a>构成。TCP 只是其中的一层，有着自己的分工。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060804.png"></p><p>（图片说明：TCP 是以太网协议和 IP 协议的上层协议，也是应用层协议的下层协议。）</p><p>最底层的以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060802.jpg"></p><p>（图片说明：以太网协议解决了局域网的点对点通信。）</p><p>但是，以太网协议不能解决多个局域网如何互通，这由 IP 协议解决。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060803.png"></p><p>（图片说明：IP 协议可以连接多个局域网。）</p><p>IP 协议定义了一套自己的地址规则，称为 IP 地址。它实现了路由功能，允许某个局域网的 A 主机，向另一个局域网的 B 主机发送消息。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060805.jpg"></p><p>（图片说明：路由器就是基于 IP 协议。局域网之间要靠路由器连接。）</p><p>路由的原理很简单。市场上所有的路由器，背后都有很多网口，要接入多根网线。路由器内部有一张路由表，规定了 A 段 IP 地址走出口一，B 段地址走出口二，……通过这套”指路牌”，实现了数据包的转发。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060806.jpg"></p><p>（图片说明：本机的路由表注明了不同 IP 目的地的数据包，要发送到哪一个网口（interface）。）</p><p>IP 协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要依靠 TCP 协议。</p><p>简单说，TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。</p><h2 id="二、TCP-数据包的大小"><a href="#二、TCP-数据包的大小" class="headerlink" title="二、TCP 数据包的大小"></a>二、TCP 数据包的大小</h2><p>以太网数据包（packet）的大小是固定的，最初是 1518 字节，后来增加到 1522 字节。其中， 1500 字节是负载（payload），22 字节是头信息（head）。</p><p>IP 数据包在以太网数据包的负载里面，它也有自己的头信息，最少需要 20 字节，所以 IP 数据包的负载最多为 1480 字节。</p><p><img src="/blogimg/asset/201205/bg2012052913.png"></p><p>（图片说明：IP 数据包在以太网数据包里面，TCP 数据包在 IP 数据包里面。）</p><p>TCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要 20 字节，因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节。由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为 1400 字节左右。</p><p>因此，一条 1500 字节的信息需要两个 TCP 数据包。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg20170060810.png"></p><p>（图片说明：以太网数据包的负载是 1500 字节，TCP 数据包的负载在 1400 字节左右。）</p><h2 id="三、TCP-数据包的编号（SEQ）"><a href="#三、TCP-数据包的编号（SEQ）" class="headerlink" title="三、TCP 数据包的编号（SEQ）"></a>三、TCP 数据包的编号（SEQ）</h2><p>一个包 1400 字节，那么一次性发送大量数据，就必须分成多个包。比如，一个 10MB 的文件，需要发送 7100 多个包。</p><p>发送的时候，TCP 协议为每个包编号（sequence number，简称 SEQ），以便接收的一方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。</p><p>第一个包的编号是一个随机数。为了便于理解，这里就把它称为 1 号包。假定这个包的负载长度是 100 字节，那么可以推算出下一个包的编号应该是 101。这就是说，每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。接收方由此知道，应该按照什么顺序将它们还原成原始文件。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060807.png"></p><p>（图片说明：当前包的编号是 45943，下一个数据包的编号是 46183，由此可知，这个包的负载是 240 字节。）</p><h2 id="四、TCP-数据包的组装"><a href="#四、TCP-数据包的组装" class="headerlink" title="四、TCP 数据包的组装"></a>四、TCP 数据包的组装</h2><p>收到 TCP 数据包以后，组装还原是操作系统完成的。应用程序不会直接处理 TCP 数据包。</p><p>对于应用程序来说，不用关心数据通信的细节。除非线路异常，收到的总是完整的数据。应用程序需要的数据放在 TCP 数据包里面，有自己的格式（比如 HTTP 协议）。</p><p>TCP 并没有提供任何机制，表示原始文件的大小，这由应用层的协议来规定。比如，HTTP 协议就有一个头信息<code>Content-Length</code>，表示信息体的大小。对于操作系统来说，就是持续地接收 TCP 数据包，将它们按照顺序组装好，一个包都不少。</p><p>操作系统不会去处理 TCP 数据包里面的数据。一旦组装好 TCP 数据包，就把它们转交给应用程序。TCP 数据包里面有一个端口（port）参数，就是用来指定转交给监听该端口的应用程序。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060808.jpg"></p><p>（图片说明：系统根据 TCP 数据包里面的端口，将组装好的数据转交给相应的应用程序。上图中，21 端口是 FTP 服务器，25 端口是 SMTP 服务，80 端口是 Web 服务器。）</p><p>应用程序收到组装好的原始数据，以浏览器为例，就会根据 HTTP 协议的<code>Content-Length</code>字段正确读出一段段的数据。这也意味着，一次 TCP 通信可以包括多个 HTTP 通信。</p><h2 id="五、慢启动和-ACK"><a href="#五、慢启动和-ACK" class="headerlink" title="五、慢启动和 ACK"></a>五、慢启动和 ACK</h2><p>服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。</p><p>最理想的状态是，在线路允许的情况下，达到最高速率。但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。</p><p>TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。</p><p>Linux 内核里面<a href="http://elixir.free-electrons.com/linux/v4.5/source/include/net/tcp.h#L220">设定</a>了（常量<code>TCP_INIT_CWND</code>），刚开始通信的时候，发送方一次性发送 10 个数据包，即”发送窗口”的大小为 10。然后停下来，等待接收方的确认，再继续发送。</p><p>默认情况下，接收方每收到<a href="https://serverfault.com/questions/348666/when-the-tcp-engine-decides-to-send-an-ack">两个</a> TCP 数据包，就要<a href="https://stackoverflow.com/a/3604882/1194049">发送</a>一个确认消息。”确认”的英语是 acknowledgement，所以这个确认消息就简称 ACK。</p><p>ACK 携带两个信息。</p><blockquote><ul><li>期待要收到下一个数据包的编号</li><li>接收方的接收窗口的剩余容量</li></ul></blockquote><p>发送方有了这两个信息，再加上自己已经发出的数据包的最新编号，就会推测出接收方大概的接收速度，从而降低或增加发送速率。这被称为”发送窗口”，这个窗口的大小是可变的。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060809.png"></p><p>（图片说明：每个 ACK 都带有下一个数据包的编号，以及接收窗口的剩余容量。双方都会发送 ACK。）</p><p>注意，由于 TCP 通信是双向的，所以双方都需要发送 ACK。两方的窗口大小，很可能是不一样的。而且 ACK 只是很简单的几个字段，通常与数据合并在一个数据包里面发送。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060812.jpg"></p><p>（图片说明：上图一共 4 次通信。第一次通信，A 主机发给 B 主机的数据包编号是 1，长度是 100 字节，因此第二次通信 B 主机的 ACK 编号是 1 + 100 = 101，第三次通信 A 主机的数据包编号也是 101。同理，第二次通信 B 主机发给 A 主机的数据包编号是 1，长度是 200 字节，因此第三次通信 A 主机的 ACK 是 201，第四次通信 B 主机的数据包编号也是 201。）</p><p>即使对于带宽很大、线路很好的连接，TCP 也总是从 10 个数据包开始慢慢试，过了一段时间以后，才达到最高的传输速率。这就是 TCP 的慢启动。</p><h2 id="六、数据包的遗失处理"><a href="#六、数据包的遗失处理" class="headerlink" title="六、数据包的遗失处理"></a>六、数据包的遗失处理</h2><p>TCP 协议可以保证数据通信的完整性，这是怎么做到的？</p><p>前面说过，每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。</p><p>举例来说，现在收到了 4 号包，但是没有收到 5 号包。ACK 就会记录，期待收到 5 号包。过了一段时间，5 号包收到了，那么下一轮 ACK 会更新编号。如果 5 号包还是没收到，但是收到了 6 号包或 7 号包，那么 ACK 里面的编号不会变化，总是显示 5 号包。这会导致大量重复内容的 ACK。</p><p>如果发送方发现收到<a href="https://stackoverflow.com/questions/4233851/why-does-tcp-wait-for-three-duplicate-ack-before-fast-retransmit">三个</a>连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即 5 号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060811.png"></p><p>（图片说明：Host B 没有收到 100 号数据包，会连续发出相同的 ACK，触发 Host A 重发 100 号数据包。）</p><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ul><li><a href="https://www.destroyallsoftware.com/compendium/network-protocols">Network protocols for programmers who know at least one programming language</a></li></ul><p>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享 3.0 许可证</a>）</li><li>发表日期： 2017 年 6 月 8 日</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP/IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言入门教程</title>
    <link href="/2021/06/10/%E9%98%AE%E4%B8%80%E5%B3%B0_%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2021/06/10/%E9%98%AE%E4%B8%80%E5%B3%B0_%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="汇编语言入门教程"><a href="#汇编语言入门教程" class="headerlink" title="汇编语言入门教程"></a>汇编语言入门教程</h1><p>作者： <a href="http://www.ruanyifeng.com/">阮一峰</a></p><p>日期： <a href="http://www.ruanyifeng.com/blog/2018/01/">2018 年 1 月 21 日</a></p><p>学习编程其实就是学高级语言，即那些为人类设计的计算机语言。</p><p>但是，计算机不理解高级语言，必须通过编译器转成二进制代码，才能运行。学会高级语言，并不等于理解计算机实际的运行步骤。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012204.png"></p><p>计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。</p><p>汇编语言不容易学习，就连简明扼要的介绍都很难找到。下面我尝试写一篇最好懂的汇编语言教程，解释 CPU 如何执行代码。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012202.jpg"></p><h2 id="一、汇编语言是什么？"><a href="#一、汇编语言是什么？" class="headerlink" title="一、汇编语言是什么？"></a>一、汇编语言是什么？</h2><p>我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。</p><p>这些指令都是二进制的，称为操作码（opcode），比如加法指令就是<code>00000011</code>。<a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html">编译器</a>的作用，就是将高级语言写好的程序，翻译成一条条操作码。</p><p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012203.jpg"></p><p><strong>汇编语言是二进制指令的文本形式</strong>，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p><h2 id="二、来历"><a href="#二、来历" class="headerlink" title="二、来历"></a>二、来历</h2><p>最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。</p><p>为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。</p><p>这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012205.jpg"></p><p>每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。</p><h2 id="三、寄存器"><a href="#三、寄存器" class="headerlink" title="三、寄存器"></a>三、寄存器</h2><p>学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。</p><p>先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p><p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012206.png"></p><p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p><h2 id="四、寄存器的种类"><a href="#四、寄存器的种类" class="headerlink" title="四、寄存器的种类"></a>四、寄存器的种类</h2><p>早期的 x86 CPU 只有 8 个寄存器，而且每个都有不同的用途。现在的寄存器已经有 100 多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。</p><blockquote><ul><li>EAX</li><li>EBX</li><li>ECX</li><li>EDX</li><li>EDI</li><li>ESI</li><li>EBP</li><li>ESP</li></ul></blockquote><p>上面这 8 个寄存器之中，前面七个都是通用的。ESP 寄存器有特定用途，保存当前 Stack 的地址（详见下一节）。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012207.png"></p><p>我们常常看到 32 位 CPU、64 位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是 4 个字节。</p><h2 id="五、内存模型：Heap"><a href="#五、内存模型：Heap" class="headerlink" title="五、内存模型：Heap"></a>五、内存模型：Heap</h2><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p><p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012208.png"></p><p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到 10 个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到 22 个字节，那么就分配到<code>0x1020</code>。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012209.png"></p><p>这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p><h2 id="六、内存模型：Stack"><a href="#六、内存模型：Stack" class="headerlink" title="六、内存模型：Stack"></a>六、内存模型：Stack</h2><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012210.png"></p><p>请看下面的例子。</p><blockquote><pre><code>int main() &#123;   int a = 2;   int b = 3;&#125;</code></pre></blockquote><p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如<code>a</code>和<code>b</code>）都保存在这个帧里面。<code>main</code>函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012211.png"></p><p>如果函数内部调用了其他函数，会发生什么情况？</p><blockquote><pre><code>int main() &#123;   int a = 2;   int b = 3;   return add_a_and_b(a, b);&#125;</code></pre></blockquote><p>上面代码中，<code>main</code>函数内部调用了<code>add_a_and_b</code>函数。执行到这一行的时候，系统也会为<code>add_a_and_b</code>新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012212.png"></p><p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p><p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做”入栈”，英文是 push；栈的回收叫做”出栈”，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做”后进先出”的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012213.jpg"></p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012214.jpg"></p><p>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是 16 字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要 64 字节，那么地址就会移动到<code>0x7FB0</code>。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012215.png"></p><h2 id="七、CPU-指令"><a href="#七、CPU-指令" class="headerlink" title="七、CPU 指令"></a>七、CPU 指令</h2><h3 id="7-1-一个实例"><a href="#7-1-一个实例" class="headerlink" title="7.1 一个实例"></a>7.1 一个实例</h3><p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序<code>example.c</code>。</p><blockquote><pre><code>int add_a_and_b(int a, int b) &#123;   return a + b;&#125;int main() &#123;   return add_a_and_b(2, 3);&#125;</code></pre></blockquote><p>gcc 将这个程序转成汇编语言。</p><blockquote><pre><code>$ gcc -S example.c</code></pre></blockquote><p>上面的命令执行以后，会生成一个文本文件<code>example.s</code>，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p><p><code>example.s</code>经过简化以后，大概是下面的样子。</p><blockquote><pre><code>_add_a_and_b:   push   %ebx   mov    %eax, [%esp+8]   mov    %ebx, [%esp+12]   add    %eax, %ebx   pop    %ebx   ret_main:   push   3   push   2   call   _add_a_and_b   add    %esp, 8   ret</code></pre></blockquote><p>可以看到，原程序的两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数所转成的 CPU 运行流程。</p><p>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。</p><blockquote><pre><code>push   %ebx</code></pre></blockquote><p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p><p>下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。</p><h3 id="7-2-push-指令"><a href="#7-2-push-指令" class="headerlink" title="7.2 push 指令"></a>7.2 push 指令</h3><p>根据约定，程序从<code>_main</code>标签开始执行，这时会在 Stack 上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在 ESP 寄存器所保存的地址。</p><p>然后，开始执行第一行代码。</p><blockquote><pre><code>push   3</code></pre></blockquote><p><code>push</code>指令用于将运算子放入 Stack，这里就是将<code>3</code>写入<code>main</code>这个帧。</p><p>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去 4 个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4 个字节则是因为<code>3</code>的类型是<code>int</code>，占用 4 个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。</p><blockquote><pre><code>push   2</code></pre></blockquote><p>第二行也是一样，<code>push</code>指令将<code>2</code>写入<code>main</code>这个帧，位置紧贴着前面写入的<code>3</code>。这时，ESP 寄存器会再减去 4 个字节（累计减去 8）。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012216.png"></p><h3 id="7-3-call-指令"><a href="#7-3-call-指令" class="headerlink" title="7.3 call 指令"></a>7.3 call 指令</h3><p>第三行的<code>call</code>指令用来调用函数。</p><blockquote><pre><code>call   _add_a_and_b</code></pre></blockquote><p>上面的代码表示调用<code>add_a_and_b</code>函数。这时，程序就会去找<code>_add_a_and_b</code>标签，并为该函数建立一个新的帧。</p><p>下面就开始执行<code>_add_a_and_b</code>的代码。</p><blockquote><pre><code>push   %ebx</code></pre></blockquote><p>这一行表示将 EBX 寄存器里面的值，写入<code>_add_a_and_b</code>这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p><p>这时，<code>push</code>指令会再将 ESP 寄存器里面的地址减去 4 个字节（累计减去 12）。</p><h3 id="7-4-mov-指令"><a href="#7-4-mov-指令" class="headerlink" title="7.4 mov 指令"></a>7.4 mov 指令</h3><p><code>mov</code>指令用于将一个值写入某个寄存器。</p><blockquote><pre><code>mov    %eax, [%esp+8]</code></pre></blockquote><p>这一行代码表示，先将 ESP 寄存器里面的地址加上 8 个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是<code>2</code>，再将<code>2</code>写入 EAX 寄存器。</p><p>下一行代码也是干同样的事情。</p><blockquote><pre><code>mov    %ebx, [%esp+12]</code></pre></blockquote><p>上面的代码将 ESP 寄存器的值加 12 个字节，再按照这个地址在 Stack 取出数据，这次取出的是<code>3</code>，将其写入 EBX 寄存器。</p><h3 id="7-5-add-指令"><a href="#7-5-add-指令" class="headerlink" title="7.5 add 指令"></a>7.5 add 指令</h3><p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子。</p><blockquote><pre><code>add    %eax, %ebx</code></pre></blockquote><p>上面的代码将 EAX 寄存器的值（即 2）加上 EBX 寄存器的值（即 3），得到结果 5，再将这个结果写入第一个运算子 EAX 寄存器。</p><h3 id="7-6-pop-指令"><a href="#7-6-pop-指令" class="headerlink" title="7.6 pop 指令"></a>7.6 pop 指令</h3><p><code>pop</code>指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。</p><blockquote><pre><code>pop    %ebx</code></pre></blockquote><p>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p><p>注意，<code>pop</code>指令还会将 ESP 寄存器里面的地址加 4，即回收 4 个字节。</p><h3 id="7-7-ret-指令"><a href="#7-7-ret-指令" class="headerlink" title="7.7 ret 指令"></a>7.7 ret 指令</h3><p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。</p><blockquote><pre><code>ret</code></pre></blockquote><p>可以看到，该指令没有运算子。</p><p>随着<code>add_a_and_b</code>函数终止执行，系统就回到刚才<code>main</code>函数中断的地方，继续往下执行。</p><blockquote><pre><code>add    %esp, 8</code></pre></blockquote><p>上面的代码表示，将 ESP 寄存器里面的地址，手动加上 8 个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的<code>pop</code>操作已经回收了 4 个字节，这里再回收 8 个字节，等于全部回收。</p><blockquote><pre><code>ret</code></pre></blockquote><p>最后，<code>main</code>函数运行结束，<code>ret</code>指令退出程序执行。</p><h2 id="八、参考链接"><a href="#八、参考链接" class="headerlink" title="八、参考链接"></a>八、参考链接</h2><ul><li><a href="http://kakaroto.homelinux.net/2017/11/introduction-to-reverse-engineering-and-assembly/">Introduction to reverse engineering and Assembly</a>, by Youness Alaoui</li><li><a href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html">x86 Assembly Guide</a>, by University of Virginia Computer Science</li></ul><p>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享 3.0 许可证</a>）</li><li>发表日期： 2018 年 1 月 21 日</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown学习笔记1</title>
    <link href="/2021/06/08/markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/2021/06/08/markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h1 id="markdown学习笔记1"><a href="#markdown学习笔记1" class="headerlink" title="markdown学习笔记1"></a>markdown学习笔记1</h1><h2 id="1、markdown是什么？"><a href="#1、markdown是什么？" class="headerlink" title="1、markdown是什么？"></a>1、markdown是什么？</h2><ul><li>Markdown是一种轻量级标记语言，2004 由约翰·格鲁伯（英语：John Gruber）创建，通过使用易读易写的纯文本格式编写文档，让作者把更多精力放在文章内容，不再为排版浪费时间。Markdown文档可以导出为HTML、Word、图像、PDF、Epub 等多种格式。</li></ul><h2 id="2、标题、换行、字体"><a href="#2、标题、换行、字体" class="headerlink" title="2、标题、换行、字体"></a>2、标题、换行、字体</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><ul><li>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</li></ul><blockquote><p>#一级标题<br>##二级标题<br>###三级标题<br>####四级标题<br>#####五级标题<br>######六级标题  </p></blockquote><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul><li>段落的换行是使用两个以上空格再加上回车。</li><li>或者使用一个空行来表示新的段落段落。</li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><blockquote><p>* 斜体文本 *<br>**粗体文本**<br>***粗斜体文本***  </p></blockquote><blockquote><p><em>斜体文本</em><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em>  </p></blockquote><h2 id="3、分割线、删除线、下划线"><a href="#3、分割线、删除线、下划线" class="headerlink" title="3、分割线、删除线、下划线"></a>3、分割线、删除线、下划线</h2><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><ul><li>在一行中用三个以上的星号、减号、底线来建立一个分隔线<blockquote><p>-–<br>分割线  </p></blockquote></li></ul><blockquote><hr><p>分割线  </p></blockquote><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><ul><li>在文字的两端加上两个波浪线表示删除线</li></ul><blockquote><p>~~删除线~~</p></blockquote><blockquote><p><del>删除线</del>  </p></blockquote><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><ul><li>通过 HTML 的 &lt;u&gt; &lt;/u&gt;标签来表示下划线<blockquote><p>&lt;u&gt; 下划线 &lt;/u&gt;</p></blockquote></li></ul><blockquote><p><u> 下划线 </u></p></blockquote><h2 id="4、有序列表、无序列表、列表嵌套"><a href="#4、有序列表、无序列表、列表嵌套" class="headerlink" title="4、有序列表、无序列表、列表嵌套"></a>4、有序列表、无序列表、列表嵌套</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul><li>无序列表使用星号*、加号+或是减号-  </li></ul><blockquote><p>- 第一项<br>- 第二项<br>- 第三项  </p></blockquote><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ul><li>有序列表使用数字并加上点号 . <blockquote><p>1. 第一项<br>2. 第二项<br>3. 第三项  </p></blockquote></li></ul><blockquote><ol><li>第一项  </li><li>第二项  </li><li>第三项</li></ol></blockquote><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><ul><li>在子列表中的选项前面添加四个空格</li></ul><blockquote><p>1. 第一项：<br>&emsp;    - 第一项嵌套的第一个元素<br>&emsp;    - 第一项嵌套的第二个元素<br>2. 第二项：<br>&emsp;    - 第二项嵌套的第一个元素<br>&emsp;    - 第二项嵌套的第二个元素  </p></blockquote><blockquote><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol></blockquote><h2 id="6、区块显示"><a href="#6、区块显示" class="headerlink" title="6、区块显示"></a>6、区块显示</h2><h3 id="普通区块"><a href="#普通区块" class="headerlink" title="普通区块"></a>普通区块</h3><ul><li>区块引用是在段落开头使用 &gt; 符号，后跟空格。<blockquote><p>&gt; 第一行<br>&gt; 第二行<br>&gt; 第三行  </p></blockquote></li></ul><blockquote><p>第一行<br>第二行<br>第三行  </p></blockquote><h3 id="嵌套区块"><a href="#嵌套区块" class="headerlink" title="嵌套区块"></a>嵌套区块</h3><ul><li>区块可以嵌套，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推。<blockquote><p>&gt; 第一行<br>&gt;&gt; 第二行<br>&gt;&gt;&gt; 第三行  </p></blockquote></li></ul><blockquote><p>第一行  </p><blockquote><p>第二行  </p><blockquote><p>第三行  </p></blockquote></blockquote></blockquote><h3 id="区块加入列表"><a href="#区块加入列表" class="headerlink" title="区块加入列表"></a>区块加入列表</h3><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h3 id="列表加入区块"><a href="#列表加入区块" class="headerlink" title="列表加入区块"></a>列表加入区块</h3><ul><li>在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。</li><li>第一项<blockquote><p>第一行<br>第二行</p></blockquote></li><li>第二项<blockquote><p>第一行<br>第二行</p></blockquote></li></ul><h2 id="7、代码显示"><a href="#7、代码显示" class="headerlink" title="7、代码显示"></a>7、代码显示</h2><ul><li>代码可以用反引号把它包起来 `<blockquote><p>`printf(“Hello World ! \n”);`  </p></blockquote></li></ul><blockquote><p><code>printf(&quot;Hello World ! \n&quot;);</code></p></blockquote><ul><li>以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）  </li></ul><blockquote><p>```c<br>printf(“Hello World ! \n”);<br>```</p></blockquote><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World ! \n&quot;</span>);<br></code></pre></td></tr></table></figure></blockquote><ul><li>用区块显示代码，代码区块使用 4 个空格或者一个制表符（Tab 键）  <blockquote><p>for(int i=0;i&lt;100;i++)<br>  {<br>  &emsp; printf(“Hello World ! \n”);<br>  }</p></blockquote></li></ul><h2 id="8、添加链接"><a href="#8、添加链接" class="headerlink" title="8、添加链接"></a>8、添加链接</h2><ul><li>[链接名称](链接地址)</li></ul><blockquote><p>[跑跑的小屋](liupaopao.top)  </p></blockquote><blockquote><p><a href="liupaopao.top">跑跑的小屋</a></p></blockquote><ul><li>&lt;链接地址&gt;</li></ul><blockquote><p>&lt;<a href="https://liupaopao.top&gt;/">https://liupaopao.top&gt;</a> </p></blockquote><blockquote><p><a href="https://liupaopao.top/">https://liupaopao.top</a> </p></blockquote><h2 id="9、添加图片"><a href="#9、添加图片" class="headerlink" title="9、添加图片"></a>9、添加图片</h2><ul><li>要添加图片，首先添加感叹号（!），然后紧跟着是方括号，方括号中可添加替代文本（alt text，即图片显示失败后显示此文本），最后跟着圆括号，圆括号中添加图片资源的路径或 URL。你可以选择在圆括号中的 URL 之后添加标题（即 title 属性）。</li></ul><blockquote><p>![alt 属性文本](图片地址)<br>![alt 属性文本](图片地址 “可选标题”)</p></blockquote><blockquote><p>![百度logo](<a href="https://dss2.bdstatic.com/5bVYsj_p_tVS5dKfpU_Y_D3/res/r/image/2021-3-4/hao123%20logo.png">https://dss2.bdstatic.com/5bVYsj_p_tVS5dKfpU_Y_D3/res/r/image/2021-3-4/hao123%20logo.png</a> “baidu”)</p></blockquote><blockquote><p><img src="https://dss2.bdstatic.com/5bVYsj_p_tVS5dKfpU_Y_D3/res/r/image/2021-3-4/hao123%20logo.png" alt="百度logo" title="baidu"></p></blockquote><h2 id="10、添加表格"><a href="#10、添加表格" class="headerlink" title="10、添加表格"></a>10、添加表格</h2><ul><li>使用三个或更多个连字符（—）来为每个列创建表头，并使用管道符（|）来分隔每个列。</li></ul><blockquote><p>|  表头 | 表头  |<br>|  —  | —  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |  </p></blockquote><blockquote><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table></blockquote><ul><li>可以设置表格的对齐方式：</li></ul><blockquote><table><thead><tr><th>符号</th><th>对齐方式</th></tr></thead><tbody><tr><td>-:</td><td>设置内容和标题栏居右对齐</td></tr><tr><td>:-</td><td>设置内容和标题栏居左对齐</td></tr><tr><td>:-:</td><td>设置内容和标题栏居中对齐</td></tr></tbody></table></blockquote>]]></content>
    
    
    <categories>
      
      <category>Markdown技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim中可视模式下添加或取消多行注释</title>
    <link href="/2021/06/06/Vim-vim%E4%B8%AD%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B7%BB%E5%8A%A0%E6%88%96%E5%8F%96%E6%B6%88%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A/"/>
    <url>/2021/06/06/Vim-vim%E4%B8%AD%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B7%BB%E5%8A%A0%E6%88%96%E5%8F%96%E6%B6%88%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="vim中可视模式下多行添加注释和取消注释"><a href="#vim中可视模式下多行添加注释和取消注释" class="headerlink" title="vim中可视模式下多行添加注释和取消注释"></a>vim中可视模式下多行添加注释和取消注释</h2><p><strong>正常模式 –&gt; 可视模式：</strong></p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>v</td><td>可视模式</td></tr><tr><td>ctrl+v</td><td>可视块模式</td></tr><tr><td>shift+v</td><td>可视行模式</td></tr></tbody></table><p>可视块模式有一个非常实用的作用：选多行进行注释</p><h2 id="多行添加注释："><a href="#多行添加注释：" class="headerlink" title="多行添加注释："></a>多行添加注释：</h2><p>- 光标置于行首<br>- <code>ctrl + v</code>，进入可视块模式<br>- 移动光标，选中的位置会有高亮显示<br>- <code>shift + i</code>，进入 insert 模式<br>- 输入<code>//</code><br>- <code>esc</code></p><h2 id="多行取消注释："><a href="#多行取消注释：" class="headerlink" title="多行取消注释："></a>多行取消注释：</h2><p>- 光标置于行首<br>- <code>ctrl + v</code>，进入可视块模式<br>- 移动光标，选中的位置会有高亮显示<br>- 按<code>d</code></p>]]></content>
    
    
    <categories>
      
      <category>Vim技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查看gcc的宏定义</title>
    <link href="/2021/06/06/gcc-%E6%9F%A5%E7%9C%8Bgcc%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    <url>/2021/06/06/gcc-%E6%9F%A5%E7%9C%8Bgcc%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h2 id="1、查看gcc默认的内置宏定义"><a href="#1、查看gcc默认的内置宏定义" class="headerlink" title="1、查看gcc默认的内置宏定义"></a>1、查看gcc默认的内置宏定义</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">gcc -dM -E - &lt; <span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc -dM -E helloworld.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p> helloworld.c为用户随意编写的c测试用例，随意拿个c程序就行。</p><p>-E 预处理后即停止，不进行编译。预处理后的代码送往标准输出。GCC忽略任何不需要预处理的输入文件。</p><p>-dM 告诉预处理器输出有效的宏定义列表(预处理结束时仍然有效的宏定义)。该选项需结合`-E’选项使用。</p><h2 id="2、打开用户自行设置的宏定义"><a href="#2、打开用户自行设置的宏定义" class="headerlink" title="2、打开用户自行设置的宏定义"></a>2、打开用户自行设置的宏定义</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc -DDEBUG helloworld.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p>helloworld.c文件中的宏定义DEBUG如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DEBUG</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DEBUG is defined ! &quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DEBUG is not defined ! &quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="总结：gcc内部默认的宏定义-用户自行设置的宏定义-所有的宏定义"><a href="#总结：gcc内部默认的宏定义-用户自行设置的宏定义-所有的宏定义" class="headerlink" title="总结：gcc内部默认的宏定义+用户自行设置的宏定义=所有的宏定义"></a>总结：gcc内部默认的宏定义+用户自行设置的宏定义=所有的宏定义</h2>]]></content>
    
    
    <categories>
      
      <category>编译器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记1：单片机最小系统设计</title>
    <link href="/2021/05/27/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/2021/05/27/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h2 id="1、单片机概念"><a href="#1、单片机概念" class="headerlink" title="1、单片机概念"></a>1、单片机概念</h2><p>单片机：一种集成电路芯片，是单片微型计算机的简称。单片机由微处理器CPU、存储器ROM和RAM、输入输出IO接口电路组成，构成了一个既小巧又完善的计算机硬件系统。</p><h2 id="2、单片机用途"><a href="#2、单片机用途" class="headerlink" title="2、单片机用途"></a>2、单片机用途</h2><p>（1）智能仪器仪表，如示波器、万用表</p><p>（2）机电一体化产品，如机器人、数控机床、打印机</p><p>（3）实时工业控制，如电机转速控制</p><p>（4）家用电器，如冰箱、洗衣机</p><h2 id="3、单片机应用系统"><a href="#3、单片机应用系统" class="headerlink" title="3、单片机应用系统"></a>3、单片机应用系统</h2><p>单片机应用系统=软件+硬件（单片机+接口电路及外部设备）</p><p>单片机应用系统是以单片机为核心，配以输入、输出、显示、控制等外围电路和相应的控制、驱动软件，能完成一种或多种功能的使用系统。</p><h2 id="4、MCS-51系列单片机组成结构"><a href="#4、MCS-51系列单片机组成结构" class="headerlink" title="4、MCS-51系列单片机组成结构"></a>4、MCS-51系列单片机组成结构</h2><p>（1）中央处理器-CPU：8位数据宽度，能同时处理8位二进制数据或代码。</p><p>（2）数据存储器-RAM：8051单片机有128B数据存储器和21个专用寄存器，用户能使用的只有128B，专用寄存器通常用于存放控制指令数据，不能存放用户数据。</p><p>（3）程序存储器-ROM：8051单片机有4KB程序存储器，掉电后数据不会丢失。</p><p>（4）定时/计数器：8051单片机有2个16位的可编程定时/计数器。</p><p>（5）并行I/O口：8051单片机有4个8位的并行I/O口（P0/P1/P2/P3）。</p><p>（6）全双工串行口：8051单片机有一个全双工异步串行通信口。</p><p>（7）中断系统：8051单片机有5个中断源（2个外中断、2个定时/计数器中断和1个串行中断）。</p><p>（8）时钟电路：8051单片机有时钟电路，只需外接晶振和震荡电容，用于产生时序脉冲供整个单片机运行。</p><h2 id="5、MCS-51系列单片机引脚介绍"><a href="#5、MCS-51系列单片机引脚介绍" class="headerlink" title="5、MCS-51系列单片机引脚介绍"></a>5、MCS-51系列单片机引脚介绍</h2><p><img src="https://img2020.cnblogs.com/blog/1729775/202102/1729775-20210221184228988-605752706.png" alt="img"></p><p> （1）电源：40引脚Vcc接电源+5V，20引脚GND接地。</p><p>（2）时钟：19引脚XTAL1是内部振荡电路输入端。当采用外部振荡器时，此引脚接地。18引脚XTAL2是内部振荡电路输出端。当采用外部振荡器时，此引脚接外部振荡源。</p><p>（3）控制总线：</p><p>（4）I/O线：</p><p>P0口（32~39引脚）双向数据总线和低8位地址总线。</p><p>P1口（1~8引脚）准双向输入/输出口。</p><p>P2口（21~28引脚）准双向输入/输出口，访问外部存储器时用作高8位地址总线。</p><p>P3口（10~17引脚）准双向输入/输出口。P3口还具第二功能。</p><p><img src="https://img2020.cnblogs.com/blog/1729775/202102/1729775-20210221194123546-1287876210.png" alt="img"></p><h2 id="6、MCS-51系列单片机存储器结构"><a href="#6、MCS-51系列单片机存储器结构" class="headerlink" title="6、MCS-51系列单片机存储器结构"></a>6、MCS-51系列单片机存储器结构</h2><p>程序存储器：存放程序和表格常数。</p><p>数据存储器：存放程序运行所需要的参数和运行结果。</p><p>从物理存储介质来看，MCS-51系列单片机共有4种存储空间：片内程序存储器、片外程序存储器、片内数据存储器和片外数据存储器。</p><p>从逻辑地址空间来看，MCS-51系列单片机可分为3部分：程序存储器、片外数据存储器和片内数据存储器。</p><p>单片机复位后，程序计数器PC为0000H，系统从0000H单元开始取指令并执行。</p><h2 id="7、单片机最小系统电路"><a href="#7、单片机最小系统电路" class="headerlink" title="7、单片机最小系统电路"></a>7、单片机最小系统电路</h2><p>单片机最小系统电路是指单片机工作不可或缺的最基本连接电路。</p><p><strong>单片机最小系统电路包括单片机芯片、电源电路、时钟电路和复位电路四部分。</strong></p><p>（1）时钟电路。单片机内部有一个高增益反向放大器，其频率范围为1.2<del>12MHz，XTAL1和XTAL2分别为放大器的输入端和输出端。XTAL1和XTAL2外接定时元件就能构成自激振荡电路。定时元件通常采用石英晶体和电容组成的并联谐振电路。电容C1和C2主要起频率微调作用，电容取值30</del>40pF。</p><p><strong>振荡周期：振荡源的周期，若内部产生，则为石英晶体的振荡周期。</strong></p><p><strong>时钟周期：振荡周期的两倍。</strong></p><p><strong>机器周期：等于6个时钟周期，12个振荡周期。</strong></p><p><strong>指令周期：完成一条操作所需要的全部时间，每条指令的执行时间都是一个或几个机器周期组成。</strong></p><p>例题：单片机采用内部时钟，晶振频率f为6MHz，则：</p><p>振荡周期=1/6 MHz=1/6 us</p><p>时钟周期=1/3 us</p><p>机器周期=2 us</p><p>指令周期=机器周期的1<del>4倍=2</del>8us</p><p>（2）复位电路</p><p>主要分为两种：上电复位和按键复位电路。</p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单片机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在无锡必去的一些地标打卡点</title>
    <link href="/2021/05/25/%E5%9C%A8%E6%97%A0%E9%94%A1%E5%BF%85%E5%8E%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%B0%E6%A0%87%E6%89%93%E5%8D%A1%E7%82%B9/"/>
    <url>/2021/05/25/%E5%9C%A8%E6%97%A0%E9%94%A1%E5%BF%85%E5%8E%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%B0%E6%A0%87%E6%89%93%E5%8D%A1%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="灵山大佛"><a href="#灵山大佛" class="headerlink" title="灵山大佛"></a>灵山大佛</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/%E7%81%B5%E5%B1%B1%E5%A4%A7%E4%BD%9B.jpg" alt="灵山大佛"></p><h2 id="鼋头渚"><a href="#鼋头渚" class="headerlink" title="鼋头渚"></a>鼋头渚</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/%E9%BC%8B%E5%A4%B4%E6%B8%9A%E6%A8%B1%E8%8A%B11.jpg" alt="鼋头渚樱花1"></p><h2 id="惠山"><a href="#惠山" class="headerlink" title="惠山"></a>惠山</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/%E6%97%A0%E9%94%A1%E6%83%A0%E5%B1%B1%E5%AF%BA%E7%A7%8B%E6%99%AF.jpg" alt="无锡惠山寺秋景"></p><h2 id="南长街、清明桥、古运河"><a href="#南长街、清明桥、古运河" class="headerlink" title="南长街、清明桥、古运河"></a>南长街、清明桥、古运河</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/%E5%8D%97%E9%95%BF%E8%A1%97%E6%B8%85%E5%90%8D%E6%A1%A5%E5%8F%A4%E8%BF%90%E6%B2%B3%E6%99%AF%E5%8C%BA.jpg" alt="南长街清名桥古运河景区"></p><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/%E5%8F%A4%E8%BF%90%E6%B2%B31.jpg" alt="古运河1"></p><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/%E5%8F%A4%E8%BF%90%E6%B2%B32.jpg" alt="古运河2"></p><h2 id="蠡湖公园"><a href="#蠡湖公园" class="headerlink" title="蠡湖公园"></a>蠡湖公园</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/%E6%97%A0%E9%94%A1%E8%A0%A1%E5%9B%AD%E5%9B%9B%E5%AD%A3%E4%BA%AD.jpg" alt="无锡蠡园四季亭"></p><h2 id="梅园"><a href="#梅园" class="headerlink" title="梅园"></a>梅园</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/%E6%A2%85%E5%9B%AD.jpg" alt="梅园"></p><h2 id="蠡湖"><a href="#蠡湖" class="headerlink" title="蠡湖"></a>蠡湖</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/%E8%A0%A1%E6%B9%961.jpg" alt="蠡湖1"></p><h2 id="太湖"><a href="#太湖" class="headerlink" title="太湖"></a>太湖</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/%E5%A4%AA%E6%B9%961.png" alt="太湖1"></p><h2 id="梅里古都"><a href="#梅里古都" class="headerlink" title="梅里古都"></a>梅里古都</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/%E6%A2%85%E9%87%8C%E5%8F%A4%E9%83%BD.jpg" alt="梅里古都"></p>]]></content>
    
    
    <categories>
      
      <category>吃喝玩乐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>吃喝玩乐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu18.04/16.04下Shadowsocks服务器端安装及优化</title>
    <link href="/2021/05/23/Ubuntu18.0416.04%E4%B8%8BShadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <url>/2021/05/23/Ubuntu18.0416.04%E4%B8%8BShadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本教程旨在提供简明的Ubuntu 16.04下安装服务器端Shadowsocks。不同于Ubuntu 16.04之前的教程，本文抛弃initd，转而使用Ubuntu 16.04支持的Systemd管理Shadowsocks的启动与停止，显得更为便捷。优化部分包括BBR、TCP Fast Open以及吞吐量优化。</p><p>本教程仅适用于Ubuntu 16.04及之后的版本，基于Python 3，支持IPv6。</p><h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装<code>pip</code></h2><p>本教程使用Python 3为载体，因Python 3对应的包管理器<code>pip3</code>并未预装，首先安装<code>pip3</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install python3-pip<br></code></pre></td></tr></table></figure><h2 id="安装Shadowsocks"><a href="#安装Shadowsocks" class="headerlink" title="安装Shadowsocks"></a>安装Shadowsocks</h2><p>因Shadowsocks作者不再维护<code>pip</code>中的Shadowsocks（定格在了2.8.2），我们使用下面的命令来安装最新版的Shadowsocks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install https://github.com/shadowsocks/shadowsocks/archive/master.zip<br></code></pre></td></tr></table></figure><p>安装完成后可以使用下面这个命令查看Shadowsocks版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ssserver --version<br></code></pre></td></tr></table></figure><p>目前会显示“Shadowsocks 3.0.0”。</p><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><p>创建Shadowsocks配置文件所在文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mkdir /etc/shadowsocks<br></code></pre></td></tr></table></figure><p>然后创建配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/shadowsocks/config.json<br></code></pre></td></tr></table></figure><p>复制粘贴如下内容（注意修改密码“password”）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;server&quot;</span>:<span class="hljs-string">&quot;::&quot;</span>,<br>    <span class="hljs-attr">&quot;server_port&quot;</span>:<span class="hljs-number">8388</span>,<br>    <span class="hljs-attr">&quot;local_address&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>    <span class="hljs-attr">&quot;local_port&quot;</span>:<span class="hljs-number">1080</span>,<br>    <span class="hljs-attr">&quot;password&quot;</span>:<span class="hljs-string">&quot;mypassword&quot;</span>,<br>    <span class="hljs-attr">&quot;timeout&quot;</span>:<span class="hljs-number">300</span>,<br>    <span class="hljs-attr">&quot;method&quot;</span>:<span class="hljs-string">&quot;chacha20-ietf-poly1305&quot;</span>,<br>    <span class="hljs-attr">&quot;fast_open&quot;</span>: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>添加配置信息多用户</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 多用户</span><br>&#123;<br>    <span class="hljs-string">&quot;server&quot;</span>:<span class="hljs-string">&quot;::&quot;</span>,<br>    <span class="hljs-string">&quot;local_address&quot;</span>:<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>    <span class="hljs-string">&quot;local_port&quot;</span>:<span class="hljs-number">1080</span>,<br>  <span class="hljs-string">&quot;port_password&quot;</span>:&#123;<br>         <span class="hljs-string">&quot;8888&quot;</span>:<span class="hljs-string">&quot;123456789&quot;</span>,<br>         <span class="hljs-string">&quot;9999&quot;</span>:<span class="hljs-string">&quot;123456789&quot;</span><br>  &#125;,<br>    <span class="hljs-string">&quot;timeout&quot;</span>:<span class="hljs-number">300</span>,<br>    <span class="hljs-string">&quot;method&quot;</span>:<span class="hljs-string">&quot;aes-256-cfb&quot;</span>,<br>    <span class="hljs-string">&quot;fast_open&quot;</span>:<span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>添加配置信息单用户</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 单用户</span><br>&#123;<br>    <span class="hljs-string">&quot;server&quot;</span>:<span class="hljs-string">&quot;::&quot;</span>,<br>    <span class="hljs-string">&quot;server_port&quot;</span>:<span class="hljs-number">8388</span>,<br>    <span class="hljs-string">&quot;local_address&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>    <span class="hljs-string">&quot;local_port&quot;</span>:<span class="hljs-number">1080</span>,<br>    <span class="hljs-string">&quot;password&quot;</span>:<span class="hljs-string">&quot;123456789&quot;</span>,<br>    <span class="hljs-string">&quot;timeout&quot;</span>:<span class="hljs-number">300</span>,<br>    <span class="hljs-string">&quot;method&quot;</span>:<span class="hljs-string">&quot;aes-256-cfb&quot;</span>,<br>    <span class="hljs-string">&quot;fast_open&quot;</span>: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">server：Shadowsocks服务器地址 <br>server_port：Shadowsocks服务器端口 <br>local_address：   本地IP<br>local_port：本地端口 <br>password：Shadowsocks连接密码 <br>timeout：等待超时时间 <br>method：加密方式 <br><span class="hljs-attr">workers</span>:          工作线程数 <br>fast_open：       <span class="hljs-literal">true</span>或<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="测试Shadowsocks配置"><a href="#测试Shadowsocks配置" class="headerlink" title="测试Shadowsocks配置"></a>测试Shadowsocks配置</h2><p>首先记录下服务器的IP地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifconfig<br></code></pre></td></tr></table></figure><p>找到IPv4地址（和IPv6地址），如我的<code>ifconfig</code>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">eth0      Link encap:Ethernet  HWaddr 46:91:89:4e:c1:52<br>          inet addr:138.68.51.55  Bcast:138.68.63.255  Mask:255.255.240.0<br>          inet6 addr: fe80::4491:89ff:fe4e:c152/64 Scope:Link<br>          inet6 addr: 2604:a880:2:d0::3727:7001/64 Scope:Global<br>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br>          RX packets:102667 errors:0 dropped:0 overruns:0 frame:0<br>          TX packets:7869 errors:0 dropped:0 overruns:0 carrier:0<br>          collisions:0 txqueuelen:1000<br>          RX bytes:151166937 (151.1 MB)  TX bytes:1151476 (1.1 MB)<br></code></pre></td></tr></table></figure><p>所以我的IPv4地址是<code>138.68.51.55</code>，IPv6地址是<code>2604:a880:2:d0::3727:7001</code>。</p><p>然后来测试下Shadowsocks能不能正常工作了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssserver -c /etc/shadowsocks/config.json<br></code></pre></td></tr></table></figure><p>在Shadowsocks客户端添加服务器，如果你使用的是我提供的那个配置文件的话，地址填写你的<code>IPv4地址</code>或<code>IPv6地址</code>，端口号为<code>8388</code>，加密方法为<code>chacha20-ietf-poly1305</code>，密码为<code>你设置的密码</code>。然后设置客户端使用全局模式，浏览器登录Google试试应该能直接打开了。</p><h2 id="配置Systemd管理Shadowsocks"><a href="#配置Systemd管理Shadowsocks" class="headerlink" title="配置Systemd管理Shadowsocks"></a>配置Systemd管理Shadowsocks</h2><p>新建Shadowsocks管理文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/systemd/system/shadowsocks-server.service<br></code></pre></td></tr></table></figure><p>复制粘贴：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">[Unit]<br>Description=Shadowsocks Server<br>After=network.target<br><br>[Service]<br>ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.json<br>Restart=on-abort<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p><code>Ctrl + O</code>保存文件，<code>Ctrl + X</code>退出。</p><p>启动Shadowsocks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start shadowsocks-server<br></code></pre></td></tr></table></figure><p>设置开机启动Shadowsocks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> shadowsocks-server<br></code></pre></td></tr></table></figure><p>至此，Shadowsock服务器端的基本配置已经全部完成了！</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>这部分属于进阶操作，在你使用Shadowsocks时感觉到延迟较大，或吞吐量较低时，可以考虑对服务器端进行优化。</p><h3 id="开启BBR"><a href="#开启BBR" class="headerlink" title="开启BBR"></a>开启BBR</h3><p>BBR系Google最新开发的TCP拥塞控制算法，目前有着较好的带宽提升效果，甚至不比老牌的锐速差。</p><h4 id="升级Linux内核"><a href="#升级Linux内核" class="headerlink" title="升级Linux内核"></a>升级Linux内核</h4><p>BBR在Linux kernel 4.9引入。首先检查服务器kernel版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uname -r<br></code></pre></td></tr></table></figure><p>如果其显示版本在4.9.0之下，则需要升级Linux内核，否则请忽略下文。</p><h4 id="开启BBR-1"><a href="#开启BBR-1" class="headerlink" title="开启BBR"></a>开启BBR</h4><p>运行<code>lsmod | grep bbr</code>，如果结果中没有<code>tcp_bbr</code>，则先运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">modprobe tcp_bbr<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;tcp_bbr&quot;</span> &gt;&gt; /etc/modules-load.d/modules.conf<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.core.default_qdisc=fq&quot;</span> &gt;&gt; /etc/sysctl.conf<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.ipv4.tcp_congestion_control=bbr&quot;</span> &gt;&gt; /etc/sysctl.conf<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sysctl -p<br></code></pre></td></tr></table></figure><p>保存生效。运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sysctl net.ipv4.tcp_available_congestion_control<br>sysctl net.ipv4.tcp_congestion_control<br></code></pre></td></tr></table></figure><p>若均有<code>bbr</code>，则开启BBR成功。</p><h3 id="优化吞吐量"><a href="#优化吞吐量" class="headerlink" title="优化吞吐量"></a>优化吞吐量</h3><p>新建配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/sysctl.d/local.conf<br></code></pre></td></tr></table></figure><p>复制粘贴：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs plain"># max open files<br>fs.file-max = 51200<br># max read buffer<br>net.core.rmem_max = 67108864<br># max write buffer<br>net.core.wmem_max = 67108864<br># default read buffer<br>net.core.rmem_default = 65536<br># default write buffer<br>net.core.wmem_default = 65536<br># max processor input queue<br>net.core.netdev_max_backlog = 4096<br># max backlog<br>net.core.somaxconn = 4096<br><br># resist SYN flood attacks<br>net.ipv4.tcp_syncookies = 1<br># reuse timewait sockets when safe<br>net.ipv4.tcp_tw_reuse = 1<br># turn off fast timewait sockets recycling<br>net.ipv4.tcp_tw_recycle = 0<br># short FIN timeout<br>net.ipv4.tcp_fin_timeout = 30<br># short keepalive time<br>net.ipv4.tcp_keepalive_time = 1200<br># outbound port range<br>net.ipv4.ip_local_port_range = 10000 65000<br># max SYN backlog<br>net.ipv4.tcp_max_syn_backlog = 4096<br># max timewait sockets held by system simultaneously<br>net.ipv4.tcp_max_tw_buckets = 5000<br># turn on TCP Fast Open on both client and server side<br>net.ipv4.tcp_fastopen = 3<br># TCP receive buffer<br>net.ipv4.tcp_rmem = 4096 87380 67108864<br># TCP write buffer<br>net.ipv4.tcp_wmem = 4096 65536 67108864<br># turn on path MTU discovery<br>net.ipv4.tcp_mtu_probing = 1<br><br>net.ipv4.tcp_congestion_control = bbr<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sysctl --system<br></code></pre></td></tr></table></figure><p>编辑之前的shadowsocks-server.service文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/systemd/system/shadowsocks-server.service<br></code></pre></td></tr></table></figure><p>在<code>ExecStart</code>前插入一行，内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ExecStartPre=/bin/sh -c &#x27;ulimit -n 51200&#x27;<br></code></pre></td></tr></table></figure><p>即修改后的shadowsocks-server.service内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">[Unit]<br>Description=Shadowsocks Server<br>After=network.target<br><br>[Service]<br>ExecStartPre=/bin/sh -c &#x27;ulimit -n 51200&#x27;<br>ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.json<br>Restart=on-abort<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p><code>Ctrl + O</code>保存文件，<code>Ctrl + X</code>退出。</p><p>重载shadowsocks-server.service：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl daemon-reload<br></code></pre></td></tr></table></figure><p>重启Shadowsocks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart shadowsocks-server<br></code></pre></td></tr></table></figure><h3 id="开启TCP-Fast-Open"><a href="#开启TCP-Fast-Open" class="headerlink" title="开启TCP Fast Open"></a>开启TCP Fast Open</h3><p>TCP Fast Open可以降低Shadowsocks服务器和客户端的延迟。实际上在上一步已经开启了TCP Fast Open，现在只需要在Shadowsocks配置中启用TCP Fast Open。</p><p>编辑config.json：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/shadowsocks/config.json<br></code></pre></td></tr></table></figure><p>将<code>fast_open</code>的值由<code>false</code>修改为<code>true</code>。<code>Ctrl + O</code>保存文件，<code>Ctrl + X</code>退出。</p><p>重启Shadowsocks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart shadowsocks-server<br></code></pre></td></tr></table></figure><p>注意：TCP Fast Open同时需要客户端的支持，即客户端Linux内核版本为3.7.1及以上；你可以在Shadowsocks客户端中启用TCP Fast Open。</p><p>至此，Shadowsock服务器端的优化已经全部完成了！</p>]]></content>
    
    
    <categories>
      
      <category>科学上网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shadowsocks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu更新SS以支持新的加密方法</title>
    <link href="/2021/05/23/Ubuntu%E6%9B%B4%E6%96%B0SS%E4%BB%A5%E6%94%AF%E6%8C%81%E6%96%B0%E7%9A%84%E5%8A%A0%E5%AF%86%E6%96%B9%E6%B3%95/"/>
    <url>/2021/05/23/Ubuntu%E6%9B%B4%E6%96%B0SS%E4%BB%A5%E6%94%AF%E6%8C%81%E6%96%B0%E7%9A%84%E5%8A%A0%E5%AF%86%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>每次用 SSH 的方式登入服务器的时候，都会提示如下信息：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">Welcome <span class="hljs-keyword">to</span> Ubuntu *.*.* LTS (GNU/Linux *.*.*-*-generic x86_64)<br><br> * Documentation:  http<span class="hljs-variable">s:</span>//<span class="hljs-keyword">help</span>.ubuntu.<span class="hljs-keyword">com</span>/<br><br> ……<br><br><span class="hljs-number">13</span> packages can <span class="hljs-keyword">be</span> updated.<br><span class="hljs-number">10</span> updates are security updates.<br></code></pre></td></tr></table></figure><p>字面提示是有 13 个包可以升级，其中 10 个是安全更新。</p><p>事实上 Ubuntu 更新还是挺容易的，因为有 <code>apt-get</code>，不过更新完之后，还是会提示一些安全更新没做完，所以找了一下解决方案。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-builtin-name">get</span> update<br>apt-<span class="hljs-builtin-name">get</span><span class="hljs-built_in"> upgrade</span><br><span class="hljs-built_in"></span>apt-<span class="hljs-builtin-name">get</span> dist-upgrade<br></code></pre></td></tr></table></figure><h4 id="命令说明："><a href="#命令说明：" class="headerlink" title="命令说明："></a>命令说明：</h4><ul><li><code>apt-get update</code> 从服务器更新可用的软件包<strong>列表</strong>。</li><li><code>apt-get upgrade</code> 根据列表，更新已安装的软件包。这个命令<strong>不会</strong>删除在列表中已经没有的软件包，<strong>也不会</strong>安装有依赖需求但尚未安装的软件包。</li><li><code>apt-get dist-upgrade</code> 根据列表，更新已安装的软件包。这个命令可能会为了解决软件包冲突而删除一些已安装的软件包，也可能会为了解决软件包依赖问题安装新的软件包。</li></ul><p>所以使用上面三个命令完成更新之后，用 <code>reboot</code> 命令重启系统就行。<strong>需要注意的是，以上所有命令都需要在 root 权限下执行。</strong></p><p>更新完成之后，去启动 SS，然后就报错了，从没见过的错误：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">load</span> libsodium failed <span class="hljs-keyword">with</span> <span class="hljs-type">path</span> <span class="hljs-keyword">None</span><br></code></pre></td></tr></table></figure><p>不清楚是更新的系统造成的，还是其他原因，反正 SS 不能用了。搜索了一下，发现用这个 lib 的话，SS 可以支持新的高效率一点的加密方式 <code>chacha20</code> 等等这些。</p><p>于是乎，装一下 <code>libsodium</code> 吧~</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">apt-<span class="hljs-built_in">get</span> install build-essential<br>wget http<span class="hljs-variable">s:</span>//download.libsodium.org/libsodium/releases/LATEST.tar.gz<br>tar xf LATEST.tar.gz &amp;&amp; <span class="hljs-keyword">cd</span> libsodium-*.*.*<br>./configure &amp;&amp; <span class="hljs-keyword">make</span> -j4 &amp;&amp; <span class="hljs-keyword">make</span> install<br></code></pre></td></tr></table></figure><p>安装完毕之后，修改 SS 配置文件，把加密换成 <code>chacha20-ietf-poly1305</code>，启动 SS，没有任何报错，一切正常。</p><p>客户端也把加密方式修改成相应的，完成~~</p><h4 id="不用自己编译的安装方式（未验证）"><a href="#不用自己编译的安装方式（未验证）" class="headerlink" title="不用自己编译的安装方式（未验证）"></a>不用自己编译的安装方式（未验证）</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">add</span>-apt-repository <span class="hljs-keyword">pp</span><span class="hljs-variable">a:chris</span>-lea/libsodium<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;deb http://ppa.launchpad.net/chris-lea/libsodium/ubuntu trusty main&quot;</span> &gt;&gt; /etc/apt/sources.<span class="hljs-keyword">list</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;deb-src http://ppa.launchpad.net/chris-lea/libsodium/ubuntu trusty main&quot;</span> &gt;&gt; /etc/apt/sources.<span class="hljs-keyword">list</span><br>apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span> &amp;&amp; apt-<span class="hljs-built_in">get</span> install libsodium-dev<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>科学上网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shadowsocks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAC模式和全局代理模式的区别</title>
    <link href="/2021/05/23/PAC%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/05/23/PAC%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="PAC模式"><a href="#PAC模式" class="headerlink" title="PAC模式"></a>PAC模式</h2><p>PAC模式也就是智能分流模式，根据规则去匹配你访问的网站，国外网站走代理，国内网站不走代理，非常智能，增加访问速度。</p><ul><li>优点：节省流量，国内网站依旧走本地网络，速度快，绝大部分国外网站都走代理，速度也快。</li><li>缺点：少部分国外网站会不经过代理，不能起到加速效果，甚至无法访问（解决方案：自己编辑PAC规则列表，将不走代理的国外网址加入进去，或者直接选择全局模式）。</li></ul><h2 id="全局模式"><a href="#全局模式" class="headerlink" title="全局模式"></a>全局模式</h2><p>全局模式就是国内、国外所有网站都走代理。</p><ul><li>优点：可访问全球所有网站。</li><li>缺点：所有网站都走代理，访问国内网站速度变慢，且耗流量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>科学上网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shadowsocks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown介绍和使用说明</title>
    <link href="/2021/05/21/markdown%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <url>/2021/05/21/markdown%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/people/chen-shu-yi-21"><img src="https://pic1.zhimg.com/v2-9d019104896d4a8c9b94ba1ea53eadc9_xs.jpg?source=172ae18b" alt="陈树义"></a></p><p><a href="https://www.zhihu.com/people/chen-shu-yi-21">陈树义</a><a href="https://www.zhihu.com/question/48510028"></a></p><p>广州唯品会信息科技有限公司 Java开发工程师</p><p>854 人赞同了该文章</p><p>写博客、写文章比较多的人都知道 Markdown 是什么。</p><blockquote><p>Markdown 是一种轻量级标记语言，创始人为 John Gruber。它允许人们「使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档」。——维基百科</p></blockquote><p>简单地说，Markdown 与 HTML 语言一样，使用一些符号就代替样式。但是它比 HTML 语言更加简单。例如我想要实现标题样式，那么我可以这么做：</p><p><img src="https://pic1.zhimg.com/80/v2-169597b288329de5b969b341c5fed180_720w.jpg" alt="img"></p><h2 id="Markdown的本质"><a href="#Markdown的本质" class="headerlink" title="Markdown的本质"></a><strong>Markdown的本质</strong></h2><p>有些朋友会觉得，我用 Word 也可以实现同样的效果，为什么要使用 Markdown 呢？这个问题提得非常好，直戳问题本质。</p><p>Word 等其他文本编辑工具虽然也能实现同样的效果，但是其功能太强大了。Word 还能改变字体颜色，还可以调节字体大小。这么强大的功能可以说是 Word 的优点，但也可以说是它的缺点。</p><p>当功能多了，我们的注意力就会分散，我们就会去纠结：这个字体大小到底是 14 还是 16 好？我想强调这一句话，是要加粗还是标红？</p><p>而 Markdown 的出现让我们不需要去纠结这些问题。<strong>Markdown 的本质是让我们回归到内容本身，注重文章本身的结构，而不是样式。</strong></p><p>例如我们想要强调一句话，那么我们直接使用两个星号为其加粗，而不需要考虑是加粗还是标红（Markdown中只有黑色字体，没有其他颜色字体）。</p><p><img src="https://pic2.zhimg.com/80/v2-51ce4ea5fbdf997b5137476c14c18135_720w.jpg" alt="img"></p><p>你也不需要关心字体大小问题，因为 Markdown 中字体大小都与结构有关，无法手动设置。一级标题字体大一些，二级标题小一些。我们只需要关注哪些是一级标题，哪些是二级标题。而不需要去纠结标题字体到底要设置多大。</p><p><strong>Markdown 的本质是让我们回归内容本身。</strong> 当你明白这个道理的时候，你会明白为什么许多功能 Markdown 没有。</p><h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a><strong>Markdown语法</strong></h2><p>原生的 Markdown 语法只包含了最基础的一些特性，例如：标题、加粗、斜体、段落、引用、超链接、图片、列表、代码块、水平分割线等。而一些自定义实现的编辑器，则有一些自定义的实现，例如：数学公式、TODO列表等。所以当你看到有一些语法在一个编辑可以用，但到另一个编辑器又用不了的时候，那么这个语法可能就不是通用的 Markdown 原生语法了。</p><p>Markdown 语法非常简单，基本上只要多用几次就会了。下面简单介绍一些常用的 Markdown 语法。</p><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a><strong>段落</strong></h3><p>Markdown 使用 <code>#</code> 号来表示段落。</p><p><img src="https://pic4.zhimg.com/80/v2-ddbecf1f0fa5a9a5e92ab996d8863d23_720w.jpg" alt="img"></p><h3 id="加粗、斜体、加粗斜体"><a href="#加粗、斜体、加粗斜体" class="headerlink" title="加粗、斜体、加粗斜体"></a><strong>加粗、斜体、加粗斜体</strong></h3><p>Markdown 使用一个星号表示斜体，两个星号表示加粗，三个星号表示加粗斜体。</p><p><img src="https://pic4.zhimg.com/80/v2-4b35d8ad9479b746fa9ea0f45c06a6c3_720w.jpg" alt="img"></p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a><strong>无序列表</strong></h3><p>使用星号或者中横线来表示无序列表，注意后面需要加个空格。</p><p><img src="https://pic4.zhimg.com/80/v2-dcc81e176f9d783776cc6adcd5098773_720w.jpg" alt="img"></p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a><strong>有序列表</strong></h3><p>使用<code>数字+.</code>来表示有序列表，后面同样需要价格空格。</p><p><img src="https://pic4.zhimg.com/80/v2-de41880f5807e6f9fdde99c2742038b7_720w.jpg" alt="img"></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h3><p>Markdown 使用 <code>&gt;</code> 符号来表示引用。</p><p><img src="https://pic1.zhimg.com/80/v2-ade3a47093a0899a08074c7fc2c167c0_720w.jpg" alt="img"></p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a><strong>超链接</strong></h3><p>Markdown 使用 <code>[]()</code> 来表示超链接，中括号表示链接文字，小括号表示链接地址。</p><p><img src="https://pic4.zhimg.com/80/v2-63cc3a2b007a0a449ac2d549d62c6277_720w.jpg" alt="img"></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a><strong>图片</strong></h3><p>图片的样式与超链接非常相似，只需在前面加个感叹号就可以了，即用<code>![]()</code>表示图片。其中中括号表示图片未加载时的提示文字，小括号表示图片地址。</p><p><img src="https://pic1.zhimg.com/80/v2-a059af56aadb832034c4057c0f136824_720w.jpg" alt="img"></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a><strong>代码块</strong></h3><p>我们使用 ` 号来表示代码块引用。</p><p><img src="https://pic2.zhimg.com/80/v2-736e127b8d833dc85e0499f7f817c3a1_720w.jpg" alt="img"></p><h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a><strong>水平分割线</strong></h3><p>使用 <code>---</code> 来表示分割线</p><p><img src="https://pic1.zhimg.com/80/v2-dc4df419d95a4bd2c05d8b7ab920fed8_720w.jpg" alt="img"></p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a><strong>表格</strong></h3><p>使用一根竖线来分隔各个单元格，使用冒号来决定单元格的对齐方向。</p><p><img src="https://pic4.zhimg.com/80/v2-3222f96f11294e78f28bc1f949965557_720w.jpg" alt="img"></p><h2 id="Markdown使用场景"><a href="#Markdown使用场景" class="headerlink" title="Markdown使用场景"></a><strong>Markdown使用场景</strong></h2><p>目前越来越多的站点都支持了 Markdown 语法，例如：Github 等代码托管平台，简书、博客园等写作平台。因此，掌握好 Markdown 语法可以非常方便地在各个主流站点使用。</p><h2 id="编辑工具"><a href="#编辑工具" class="headerlink" title="编辑工具"></a><strong>编辑工具</strong></h2><p>因为 Markdown 本质上是一个纯文本，所以任何能打开纯文本的东西都可以来编辑 Markdown。但如果你想要有预览功能，那么一款顺手的编辑功能还是有必要的。</p><p>在 Windows 上比较不错的编辑器有：MarkdownPad、Typora。在 OSX 上比较不错的编辑器有：Mou、MacDown、MWeb。</p><p>而我之前使用 MouDown 和 sublime 做简单的编辑，但是笔记等的就使用印象笔记写，而要发表的文章则使用 MWeb 编写。</p><h2 id="兼容神器"><a href="#兼容神器" class="headerlink" title="兼容神器"></a><strong>兼容神器</strong></h2><p>使用了 Markdown 可以写出条理非常清晰的文章，文章结构特别清晰。但是对于一些老编辑器而言，例如：ATLASSIAN 的 WIKI 对于 Markdown 的支持就很弱。</p><p>那么怎么办呢？</p><p>其实很简单，因为老的编辑器基本都支持 HTML，所以我们可以将 Markdown 渲染后的 HTML 复制到老编辑器。</p><p>我一般是在本地写好 Markdown 文章，之后直接复制到一个 Markdown 编辑器，然后复制对应的 HTML 文本到老编辑器中。</p><p><img src="https://pic4.zhimg.com/80/v2-394d2ecadb292765ac1d810cbe5672b3_720w.jpg" alt="img"></p><p>之后点击一下蓝色的复制按钮，就可以复制渲染后的 HTML 文本，最后直接粘贴到老编辑器中就可以了。我用的 Markdown 编辑器是：**<a href="https://link.zhihu.com/?target=https://mdnice.github.io/">https://mdnice.github.io/</a>**，样式非常漂亮。</p><h2 id="进阶应用"><a href="#进阶应用" class="headerlink" title="进阶应用"></a><strong>进阶应用</strong></h2><p>当你学会使用 Markdown 之后，你会发现 Markdown 还有更多好玩的地方。例如：开源的 gitbook 就可以教你把一个个 Markdown 文件组织起来，弄成一本电子书。</p><p><img src="https://pic2.zhimg.com/80/v2-cdc7ada790a4473145b3c1207a3f8495_720w.jpg" alt="img"></p><p>具体如何操作，可以参考这里：**<a href="https://link.zhihu.com/?target=https://github.com/chenyurong/gitbook-notebook">https://github.com/chenyurong/g</a>**</p>]]></content>
    
    
    <categories>
      
      <category>Markdown技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora+Picgo+Gitee构建网络图床笔记</title>
    <link href="/2021/05/21/Typora+Picgo+Gitee%E6%9E%84%E5%BB%BA%E7%BD%91%E7%BB%9C%E5%9B%BE%E5%BA%8A%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/05/21/Typora+Picgo+Gitee%E6%9E%84%E5%BB%BA%E7%BD%91%E7%BB%9C%E5%9B%BE%E5%BA%8A%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>之前一直在Typora上记录自己的笔记，但是发现markdown格式的笔记在插入图片时，仅能采用两种方法：1）在线图床，2）本地路径，即图片并不是像Word那样集成在文档内的，因此经过一番研究，发现了最新版的Typora已经支持在线图床功能，遂写此篇教程帮助后人构建自己的在线图床markdown笔记。</p><h2 id="所需软件"><a href="#所需软件" class="headerlink" title="所需软件"></a><strong>所需软件</strong></h2><p>typora</p><p><a href="https://link.zhihu.com/?target=https://typora.io/">https://typora.io/</a></p><p>picgo</p><p><a href="https://link.zhihu.com/?target=https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p><p>建议选择2.2.2正式版本，beta版本可能会存在不稳定的风险。</p><p><img src="https://pic3.zhimg.com/80/v2-be88c425ba401a71e9c91dca74f0d262_720w.jpg" alt="img"></p><p>Gitee</p><p>由于国内连接github时网络偶尔存在不稳定的情况，于是采用了gitee作为github图床的替代，但整体教程是一样的</p><p><a href="https://link.zhihu.com/?target=https://gitee.com/">https://gitee.com/</a></p><p><img src="https://pic3.zhimg.com/80/v2-daba73811b87533f8f032169d3d11d9a_720w.png" alt="img"></p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a><strong>具体操作</strong></h2><p>主要是分为两部分操作，第一部分是Typora的配置，第二部分是Picgo+Gitee的在线图床配置</p><h3 id="Typora配置"><a href="#Typora配置" class="headerlink" title="Typora配置"></a><strong>Typora配置</strong></h3><p>打开Typora后，点击菜单栏-文件-偏好设置</p><p>找到其中的“图像”设置，将其设置为如下内容</p><p><img src="https://pic3.zhimg.com/80/v2-f374bec8d90d87c2f7683c1133064166_720w.jpg" alt="img"></p><p>1）<strong>插入图片时…<strong>下边的选择框内选择</strong>上传图片</strong></p><p>2）勾选上“<strong>对本地位置的图片应用上述规则</strong>”</p><p>3）上传服务选择<strong>PicGo(app)</strong></p><p>4）将<strong>PicGo路径</strong>项设置为本地PicGo的安装路径</p><p>这样，我们就把Typora配置好了，下面我们进行PicGo+Gitee的网络图床构建</p><h3 id="网络图床配置"><a href="#网络图床配置" class="headerlink" title="网络图床配置"></a><strong>网络图床配置</strong></h3><p>首先，安装好PicGo之后，我们需要给PicGo配置插件以支持Gitee图床</p><p><strong>注意</strong>：你必须安装<a href="https://link.zhihu.com/?target=https://nodejs.org/en/">Node.js</a>之后才能安装PicGo的插件，因为PicGo要使用<code>npm</code>来安装插件。</p><p>安装好Nodejs后，点开左边的<strong>插件设置</strong>一栏，在输入框内输入“github plus”，如下</p><p><img src="https://pic1.zhimg.com/80/v2-270b499aeadae15d014215b32b1204c8_720w.jpg" alt="img"></p><p>点击安装此插件，之后左侧选项栏<strong>图床设置</strong>会多一个<strong>githubplus</strong></p><p><img src="https://pic1.zhimg.com/80/v2-1fd1e0c2ef8c48f1d85a5a04b8566714_720w.png" alt="img"></p><p>接下来我们配置Gitee仓库以存储图片</p><p>1）进入<a href="https://link.zhihu.com/?target=https://gitee.com/">https://gitee.com/</a>，没有账号的话，先注册账号，注册以后登录，新建一个<strong>公开仓库</strong>，名字为picgo（可以自己起其他名字）</p><p>2）点击右上角，进入<strong>设置</strong>，在左侧的<strong>安全设置-私人令牌</strong>处生成新令牌。（注意：生成的新令牌只会显示一次，一定要保存好！！！）</p><p>我们需要做的如下：</p><p>1）回到picgo，按照如下进行设置</p><p><img src="https://pic3.zhimg.com/80/v2-dceba8a3986c7df4dbc3f8cb1e8ca60e_720w.jpg" alt="img"></p><p>其中的repo为 <strong>UserName/仓库名称</strong> 格式</p><p>branch填入master</p><p>Token为刚才在Gitee生成的私人令牌，粘贴到这里就行</p><p>path为仓库下用于存储图片的路径，这个可以自行选择</p><p>最下边的origin部分选择gitee（默认是github）</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a><strong>结束</strong></h2><p>经过上述操作，我们就把typora+picgo+gitee成功配置好了，之后当我们将本地的图片粘贴到markdown文档内的时候，typora会自动将图片上传到刚才我们配置好的gitee仓库内，并自动把markdown文档内的本地路径转化为gitee的图片外链，便于我们以后进行多端访问文档内的图片。</p>]]></content>
    
    
    <categories>
      
      <category>搭建图床</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Picgo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/05/19/hello-world/"/>
    <url>/2021/05/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
